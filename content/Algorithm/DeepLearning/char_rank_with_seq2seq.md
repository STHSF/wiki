---
title: "char_rank_with_seq2seq"
layout: page
date: 2017-08-04 00:00
---

# 写在前面
为了理解弄懂seq2seq的原理和实现，模仿[知乎专栏](https://zhuanlan.zhihu.com/p/27608348)上一篇文章，对字符进行排序。


# 数据预处理
训练数据包含两部分，序列A为需要排序的字符串，序列B为已经排序的字符串。
在seq2seq中除了通常的文本预处理外，还要对序列做以下的处理，即在序列中增加以下四种字符。
- <PAD>: 序列的填充或补全，通常处理的序列长度不同，所以我们会将短序列通过<PAD>填充成长度相同的序列。
- <GO>: 在decoder的过程中告诉模型序列的开始。 
- <EOS>: 在decoder的过程告诉模型序列的结束。在有的教程中会用<EOS>替换<GO>，即序列的首尾都使用同一个标识符。这应该没有什么差别，只要自己在计算过程中能够认识就可以了。
- <UNK>: 将vocab_sie个字符数以外的字符标示为<UNK>, 通常表示低频词或者一些未遇到的词。






# 参考文献
[从Encoder到Decoder实现Seq2Seq模型](https://zhuanlan.zhihu.com/p/27608348)
