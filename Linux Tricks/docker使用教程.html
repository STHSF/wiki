<!DOCTYPE HTML>
<html>
<head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <title>docker使用教程 - LiYu's personal knowledge wiki</title>
    <meta name="keywords" content="Technology, MachineLearning, DataMining, Economics"/>
    <meta name="description" content="A wiki website of sthsf when I learned new knowledgy and technics."/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width" />

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$(',')$'], ['\\(','\\)']]}
        });
        </script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-78529611-1', 'auto');
        ga('send', 'pageview');

    </script>
</head>

<body>
<div id="container">
    
<div id="header">
  <div id="post-nav"><a href="/wiki/">Home</a>&nbsp;»&nbsp;<a href="/wiki/#Linux Tricks">Linux Tricks</a>&nbsp;»&nbsp;docker使用教程</div>
</div>
<div class="clearfix"></div>
<div id="title">docker使用教程</div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">写在前面</a></li>
<li><a href="#_2">符号约定</a></li>
<li><a href="#docker">启动和关闭docker服务</a></li>
<li><a href="#_3">基本操作</a><ul>
<li><a href="#docker_1">搜索docker镜像</a></li>
<li><a href="#_4">拉取或者下载镜像</a></li>
</ul>
</li>
<li><a href="#imagecontainer">运行image实例container</a></li>
<li><a href="#imagecontainer_1">启动和停止某个image的container</a></li>
<li><a href="#docker_2">Docker常用命令</a><ul>
<li><a href="#docker-run">docker run 其他参数</a></li>
<li><a href="#dockervim-telnetifconfig">Docker下安装vim 、telnet、ifconfig命令</a></li>
<li><a href="#docker-commitdocker-push">通过容器提交镜像（docker commit）以及推送镜像（docker push)</a></li>
</ul>
</li>
<li><a href="#docker_3">docker端口映射</a><ul>
<li><a href="#_5">创建容器时指定映射的端口</a><ul>
<li><a href="#_6">宿主机添加端口放行</a></li>
<li><a href="#docker_4">docker 多端口映射多卷映射</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#docker_5">Docker 文件传输系统</a><ul>
<li><a href="#docker_6">Docker 挂载本地目录</a></li>
<li><a href="#docker_7">Docker 和宿主机中相互传递文件</a><ul>
<li><a href="#dockercontainer">根据docker中的container的名字传送</a></li>
<li><a href="#scp">通过scp传送</a></li>
</ul>
</li>
<li><a href="#dockerssh">Docker开启ssh服务</a><ul>
<li><a href="#rootopenssh">修改root密码,安装openssh服务</a></li>
<li><a href="#_7">修改配置文件</a></li>
<li><a href="#ssh">启动ssh服务</a></li>
<li><a href="#_8">登录测试</a></li>
</ul>
</li>
<li><a href="#docker_8">Docker镜像跨服务器迁移</a><ul>
<li><a href="#1save">1、save</a></li>
<li><a href="#2export">2、export</a></li>
<li><a href="#dockerhub">Dockerhub使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#docker_9">docker 添加用户</a></li>
<li><a href="#docker_10">docker 三剑客</a><ul>
<li><a href="#docker-machine">docker machine</a></li>
<li><a href="#docker-swarm">docker swarm</a></li>
<li><a href="#docker-compose">docker compose</a></li>
</ul>
</li>
<li><a href="#centosdocker">centos下安装docker</a><ul>
<li><a href="#docker-ce">安装docker-ce</a><ul>
<li><a href="#1">方法 1</a></li>
<li><a href="#2">方法2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#centosnvidia-docker2">centos下安装nvidia-docker2</a></li>
<li><a href="#_9">参考文献</a></li>
</ul>
</div>
<h1 id="_1">写在前面</h1>
<p>linux的使用过程中经常需要涉及到编译，运行等过程。最麻烦的就是在不同的机器上重复相同的劳动，docker的存在让一切变得简单很多，下面介绍docker的一些基本知识和操作。</p>
<h1 id="_2">符号约定</h1>
<ul>
<li>
<p>&lt; xxx &gt;自定义内容</p>
</li>
<li>
<p>[ xxx ] 可选内容</p>
</li>
<li>
<p>[&lt; xxx &gt;] 自定义可选内容</p>
</li>
</ul>
<h1 id="docker">启动和关闭docker服务</h1>
<ul>
<li>启动</li>
</ul>
<div class="hlcode"><pre><span class="n">service</span> <span class="n">docker</span> <span class="n">start</span>
<span class="err">或</span>
<span class="n">systemctl</span> <span class="n">start</span> <span class="n">docker</span>
</pre></div>


<ul>
<li>关闭</li>
</ul>
<div class="hlcode"><pre><span class="n">service</span> <span class="n">docker</span> <span class="n">stop</span>
<span class="err">或</span>
<span class="n">systemctl</span> <span class="n">stop</span> <span class="n">docker</span>
</pre></div>


<h1 id="_3">基本操作</h1>
<h4 id="docker_1">搜索docker镜像</h4>
<div class="hlcode"><pre><span class="n">docker</span> <span class="n">search</span> <span class="p">[</span><span class="err">镜像名</span><span class="p">]</span>
</pre></div>


<h4 id="_4">拉取或者下载镜像</h4>
<div class="hlcode"><pre><span class="n">docker</span> <span class="n">pull</span> <span class="p">[</span><span class="n">NAME</span><span class="p">]</span>
</pre></div>


<h1 id="imagecontainer">运行image实例container</h1>
<p>对于Docker来说，image是静态的，类似于操作系统快照，而container则是动态的，是image的运行实例。<br />
先使用<code>sudo docker images</code>查看pull下来的iamge。<br />
如：</p>
<div class="hlcode"><pre><span class="n">REPOSITORY</span>           <span class="n">TAG</span>                 <span class="n">IMAGE</span> <span class="n">ID</span>            <span class="n">CREATED</span>             <span class="n">SIZE</span>
<span class="n">tensorflow</span><span class="o">/</span><span class="n">serving</span>   <span class="n">latest</span><span class="o">-</span><span class="n">devel</span><span class="o">-</span><span class="n">gpu</span>    <span class="n">e8667aaa087d</span>        <span class="mi">5</span> <span class="n">days</span> <span class="n">ago</span>          <span class="mf">4.34</span><span class="n">GB</span>
</pre></div>


<p>则可以通过下面两种方式创建一个守护态的Docker容器</p>
<div class="hlcode"><pre><span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span><span class="n">t</span> <span class="o">--</span><span class="n">privileged</span><span class="o">=</span><span class="nb">true</span> <span class="p">[</span><span class="n">tensorflow</span><span class="o">/</span><span class="n">serving</span><span class="o">:</span><span class="n">latest</span><span class="o">-</span><span class="n">devel</span><span class="o">-</span><span class="n">gpu</span><span class="p">]</span> <span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">bash</span>
<span class="err">或</span>
<span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">it</span> <span class="o">--</span><span class="n">privileged</span><span class="o">=</span><span class="nb">true</span> <span class="p">[</span><span class="n">e8667aaa087d</span><span class="p">]</span>
</pre></div>


<p>具体参数可以网上搜索, 此处必须添加--privileged=true使得容器真正获取主机硬件资源，包括GPU显卡资源.</p>
<p>这样就可以进入container了</p>
<div class="hlcode"><pre><span class="n">root</span><span class="err">@</span><span class="n">f906aeaa80e7</span><span class="o">:</span>
</pre></div>


<p>同时。我们可以在container所在的外部操作系统中运行<code>sudo docker ps</code>和<code>sudo docker ps -a</code>来分别查看运行中的container id和所有的包括未运行的container id。</p>
<div class="hlcode"><pre><span class="n">CONTAINER</span> <span class="n">ID</span>        <span class="n">IMAGE</span>                                 <span class="n">COMMAND</span>             <span class="n">CREATED</span>             <span class="n">STATUS</span>                   <span class="n">PORTS</span>                    <span class="n">NAMES</span>
<span class="mi">1</span><span class="n">a2b5c8e0f69</span>        <span class="n">tensorflow</span><span class="o">/</span><span class="n">serving</span><span class="o">:</span><span class="n">latest</span><span class="o">-</span><span class="n">devel</span><span class="o">-</span><span class="n">gpu</span>   <span class="s">&quot;/bin/bash&quot;</span>         <span class="mi">9</span> <span class="n">hours</span> <span class="n">ago</span>         <span class="n">Exited</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="mi">9</span> <span class="n">hours</span> <span class="n">ago</span>                            <span class="n">hardcore_rosalind</span>
<span class="n">c820900be758</span>        <span class="n">tensorflow</span><span class="o">/</span><span class="n">serving</span><span class="o">:</span><span class="n">latest</span><span class="o">-</span><span class="n">devel</span><span class="o">-</span><span class="n">gpu</span>   <span class="s">&quot;/bin/bash&quot;</span>         <span class="mi">20</span> <span class="n">hours</span> <span class="n">ago</span>        <span class="n">Exited</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="mi">2</span> <span class="n">hours</span> <span class="n">ago</span>                            <span class="n">brave_agnesi</span>
<span class="n">aad1b70763ab</span>        <span class="n">tensorflow</span><span class="o">/</span><span class="n">serving</span><span class="o">:</span><span class="n">latest</span><span class="o">-</span><span class="n">devel</span><span class="o">-</span><span class="n">gpu</span>   <span class="s">&quot;/bin/bash&quot;</span>         <span class="mi">20</span> <span class="n">hours</span> <span class="n">ago</span>        <span class="n">Created</span>                                           <span class="n">condescending_jackson</span>
<span class="n">f906aeaa80e7</span>        <span class="n">tensorflow</span><span class="o">/</span><span class="n">serving</span><span class="o">:</span><span class="n">latest</span><span class="o">-</span><span class="n">devel</span><span class="o">-</span><span class="n">gpu</span>   <span class="s">&quot;/bin/bash&quot;</span>         <span class="mi">20</span> <span class="n">hours</span> <span class="n">ago</span>        <span class="n">Up</span> <span class="mi">2</span> <span class="n">hours</span>               <span class="mf">0.0.0.0</span><span class="o">:</span><span class="mi">8500</span><span class="o">-&gt;</span><span class="mi">8500</span><span class="o">/</span><span class="n">tcp</span>   <span class="n">mystifying_sinoussi</span>
</pre></div>


<h1 id="imagecontainer_1">启动和停止某个image的container</h1>
<p>对于docker还是小白的我遇到这样一个问题，我pull了一个image到本地，然后运行这个image，这时候系统会生成一个contaner ID，我在contaner中安装了很多东西，比如vim，pip 之类的简单应用，并且编译了一些程序。完成之后直接退出。第二天使用的时候我还是运行了这个image，但是之前所有的配置全部没了。后来发现是自己错了，我每次运行的都是第一次pull下来的image，相当于每次启动的都是一个新的container，而我原来配置编译的那个container需要使用<code>sudo docker ps -a</code>就能看出来了。</p>
<ul>
<li><strong>启动某个container</strong></li>
</ul>
<p>如果想要再次打开之前使用过的container，则可以运行：</p>
<div class="hlcode"><pre><span class="n">sudo</span> <span class="n">docker</span> <span class="n">start</span> <span class="p">[</span><span class="n">container_name</span><span class="p">]</span>
<span class="err">或</span>
<span class="n">sudo</span> <span class="n">docker</span> <span class="n">start</span> <span class="p">[</span><span class="n">CONTAINER_ID</span><span class="p">]</span>
</pre></div>


<ul>
<li><strong>重启某个container</strong></li>
</ul>
<div class="hlcode"><pre><span class="n">sudo</span> <span class="n">docker</span> <span class="n">restart</span> <span class="p">[</span><span class="n">container_name</span><span class="p">]</span>
<span class="err">或</span>
<span class="n">sudo</span> <span class="n">docker</span> <span class="n">restart</span> <span class="p">[</span><span class="n">CONTAINER_ID</span><span class="p">]</span>
</pre></div>


<p>启动该container之后，使用<code>sudo docker attach container_name/container_id</code>进入该container。</p>
<ul>
<li><strong>进入Docker Container</strong><br />
1、Docker提供了attach命令来进入Docker容器(不建议)</li>
</ul>
<div class="hlcode"><pre><span class="n">sudo</span> <span class="n">docker</span> <span class="n">attach</span> <span class="p">[</span><span class="n">CONTAINER_ID</span><span class="p">]</span>
</pre></div>


<p>2、使用ssh进入Docker容器(不建议使用)</p>
<p>3、使用nsenter进入Docker容器(建议)<br />
<a href="https://github.com/jpetazzo/nsenter">Looking to start a shell inside a Docker container?</a></p>
<p>4、使用docker exec 进入Docker容器<br />
使用docker提供的新的命令exec进入容器</p>
<div class="hlcode"><pre><span class="n">sudo</span> <span class="n">docker</span> <span class="n">ps</span>
<span class="n">sudo</span> <span class="n">docker</span> <span class="n">exec</span> <span class="o">-</span><span class="n">it</span> <span class="p">[</span><span class="n">CONTAINER_ID</span><span class="p">]</span> <span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">bash</span>
</pre></div>


<ul>
<li><strong>退出某个Container</strong></li>
</ul>
<div class="hlcode"><pre><span class="err">直接使用</span><span class="n">Ctrl</span> <span class="o">+</span><span class="n">d</span> <span class="err">或者在</span><span class="n">container</span><span class="err">中运行</span><span class="n">exit</span>
</pre></div>


<p>如果想退出某个docker但是又不想停止docker运行,则可以使用<code>Ctrl + p + q</code>即可.</p>
<h1 id="docker_2">Docker常用命令</h1>
<p>docker的常用命令</p>
<div class="hlcode"><pre><span class="cp"># 创建Docker镜像</span>
<span class="n">docker</span> <span class="n">build</span> <span class="o">-</span><span class="n">t</span> <span class="n">fensme</span><span class="o">:</span><span class="n">v1</span>

<span class="cp"># 运行镜像</span>
<span class="n">docker</span> <span class="n">run</span> <span class="n">fensme</span>

<span class="cp"># 运行镜像并进入</span>
<span class="n">docker</span> <span class="n">run</span>  <span class="o">-</span><span class="n">i</span> <span class="o">-</span><span class="n">t</span> <span class="n">fensme</span>  <span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">bash</span>

<span class="cp"># 登录镜像平台</span>
<span class="n">docker</span> <span class="n">login</span> <span class="o">--</span><span class="n">username</span><span class="o">=</span><span class="n">bsspirit</span> <span class="o">--</span><span class="n">email</span><span class="o">=</span><span class="n">bsspirit</span><span class="err">@</span><span class="mf">163.</span><span class="n">com</span>

<span class="cp"># 增加镜像空间名</span>
<span class="n">docker</span> <span class="n">tag</span> <span class="mi">8496</span><span class="n">b10e857a</span> <span class="n">bsspirit</span><span class="o">/</span><span class="n">fensme</span><span class="o">:</span><span class="n">latest</span>

<span class="cp"># 提交镜像</span>
<span class="n">docker</span> <span class="n">push</span> <span class="n">bsspirit</span><span class="o">/</span><span class="n">fensme</span>

<span class="cp"># 删除镜像</span>
<span class="n">docker</span> <span class="n">rmi</span> <span class="o">&lt;</span><span class="n">image</span> <span class="n">id</span><span class="o">&gt;</span>

<span class="cp"># 删除所有镜像</span>
<span class="n">docker</span> <span class="n">rmi</span> <span class="err">$</span><span class="p">(</span><span class="n">docker</span> <span class="n">images</span>  <span class="o">-</span><span class="n">q</span><span class="p">)</span>

<span class="cp"># 进入镜像修改后，保存产生新镜像</span>
<span class="n">docker</span> <span class="n">commit</span> <span class="err">$</span><span class="p">(</span><span class="n">container</span> <span class="n">id</span><span class="err">前三位</span><span class="p">)</span> <span class="n">ubuntu_sshd_gerry</span><span class="o">:</span><span class="mf">14.04</span>
<span class="err">就是将修改后的</span><span class="n">continer</span><span class="err">保存为</span><span class="n">image</span><span class="p">.</span>

<span class="cp"># 停止所有的container</span>
<span class="n">docker</span>  <span class="n">stop</span> <span class="err">$</span><span class="p">(</span><span class="n">docker</span> <span class="n">ps</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">q</span><span class="p">)</span>
<span class="n">stop</span> <span class="err">后面跟</span> <span class="n">container</span> <span class="n">id</span> <span class="err">则为停止该</span><span class="n">container</span>

<span class="cp"># 删除所有的contrainer</span>
<span class="n">docker</span> <span class="n">rm</span> <span class="err">$</span><span class="p">(</span><span class="n">docker</span> <span class="n">ps</span> <span class="o">-</span><span class="n">a</span> <span class="o">-</span><span class="n">q</span><span class="p">)</span>

<span class="cp"># 进入正在运行的contrainer</span>
<span class="n">docker</span> <span class="n">attach</span> <span class="n">db3</span> 
<span class="n">docker</span> <span class="n">attach</span> <span class="n">d48b21a7e439</span>
<span class="n">attach</span> <span class="err">后面可以为</span><span class="n">container</span> <span class="n">id</span> <span class="err">也可以是</span><span class="n">container</span> <span class="n">name</span>

<span class="cp"># SSH启动</span>
<span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">it</span> <span class="o">-</span><span class="n">p</span> <span class="mi">10022</span><span class="o">:</span><span class="mi">22</span> <span class="n">vnpy</span><span class="o">:</span><span class="mf">1.2</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sshd</span> <span class="o">-</span><span class="n">D</span>
<span class="err">注意</span><span class="p">,</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">sbin</span><span class="o">/</span><span class="n">sshd</span><span class="err">是在</span><span class="n">linux</span><span class="err">环境下使用的</span><span class="p">,</span> <span class="n">windows</span><span class="err">环境可能不使用</span>
<span class="err">上面的命令是将宿主机的</span><span class="mi">10022</span><span class="err">端口和</span><span class="n">docker</span> <span class="n">container</span><span class="err">的</span><span class="mi">22</span><span class="err">端口做映射</span><span class="p">,</span><span class="err">并且在启动</span><span class="n">container</span><span class="err">的同时启动了</span><span class="n">ssh</span><span class="err">服务</span>

<span class="cp"># 重启容器</span>
<span class="n">sudo</span> <span class="n">docker</span> <span class="n">restart</span> <span class="n">ac01d678fcae</span>
<span class="n">restart</span> <span class="err">后面可以跟</span><span class="n">container</span> <span class="n">id</span> <span class="err">或者</span><span class="n">container</span> <span class="n">name</span>

<span class="cp"># docker容器运行中添加端口映射</span>
<span class="nl">https:</span><span class="c1">//my.oschina.net/u/266ΩΩΩ752/blog/541433</span>
</pre></div>


<h4 id="docker-run">docker run 其他参数</h4>
<table>
<thead>
<tr>
<th align="center">Options</th>
<th align="center">Mean</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">-a stdin</td>
<td align="center">指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="center">后台运行容器，并返回容器ID；</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">以交互模式运行容器，通常与 -t 同时使用；</td>
</tr>
<tr>
<td align="center">-P</td>
<td align="center">随机端口映射，容器内部端口随机映射到主机的高端口</td>
</tr>
<tr>
<td align="center">-p</td>
<td align="center">指定端口映射，格式为：主机(宿主)端口:容器端口</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">为容器重新分配一个伪输入终端，通常与 -i 同时使用；</td>
</tr>
<tr>
<td align="center">–name=“nginx-lb”</td>
<td align="center">为容器指定一个名称；</td>
</tr>
<tr>
<td align="center">–dns 8.8.8.8</td>
<td align="center">指定容器使用的DNS服务器，默认和宿主一致；</td>
</tr>
<tr>
<td align="center">–dns-search example.com</td>
<td align="center">指定容器DNS搜索域名，默认和宿主一致；</td>
</tr>
<tr>
<td align="center">-h “mars”</td>
<td align="center">指定容器的hostname；</td>
</tr>
<tr>
<td align="center">-e username=“ritchie”</td>
<td align="center">设置环境变量；</td>
</tr>
<tr>
<td align="center">–env-file=[]</td>
<td align="center">从指定文件读入环境变量；</td>
</tr>
<tr>
<td align="center">–cpuset=“0-2” or --cpuset=“0,1,2”</td>
<td align="center">绑定容器到指定CPU运行；</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">设置容器使用内存最大值；</td>
</tr>
<tr>
<td align="center">–net=“bridge”</td>
<td align="center">指定容器的网络连接类型，支持 bridge/host/none/</td>
</tr>
<tr>
<td align="center">–link=[]</td>
<td align="center">添加链接到另一个容器；</td>
</tr>
<tr>
<td align="center">–expose=[]</td>
<td align="center">开放一个端口或一组端口；</td>
</tr>
<tr>
<td align="center">–volume , -v</td>
<td align="center">绑定一个卷</td>
</tr>
</tbody>
</table>
<h4 id="dockervim-telnetifconfig">Docker下安装vim 、telnet、ifconfig命令</h4>
<div class="hlcode"><pre><span class="cp"># 同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。</span>
<span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">update</span>
<span class="cp"># 安装telnet</span>
<span class="err">​</span><span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span>  <span class="n">telnet</span> 
<span class="cp"># 安装ifconfig</span>
<span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span>  <span class="n">net</span><span class="o">-</span><span class="n">tools</span>
<span class="cp"># vim</span>
<span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">vim</span>
</pre></div>


<h4 id="docker-commitdocker-push">通过容器提交镜像（docker commit）以及推送镜像（docker push)</h4>
<p><a href="https://www.cnblogs.com/kevingrace/p/9599988.html">笔记</a></p>
<h1 id="docker_3">docker端口映射</h1>
<h2 id="_5">创建容器时指定映射的端口</h2>
<div class="hlcode"><pre><span class="n">run</span> <span class="p">[</span><span class="o">-</span><span class="n">P</span><span class="p">][</span><span class="o">-</span><span class="n">p</span><span class="p">]</span>
</pre></div>


<p>-P , -publish-all=true | false, 大写的P表示为容器暴露的所有的端口进行映射;</p>
<p>-p, -publish=[], 小写的p表示为容器指定的端口进行映射, 有四种形式:</p>
<ul>
<li>
<p>containerPort: 只指定容器的端口, 宿主机端口随机映射;</p>
</li>
<li>
<p>hostPort:containerPort: 同时指定容器与宿主机端口一一映射;</p>
</li>
<li>
<p>ip::containerPort: 指定ip和容器的端口;</p>
</li>
<li>
<p>ip:hostPort:containerPort: 指定ip、宿主机端口以及容器端口.</p>
</li>
</ul>
<p>例如:</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker run -p 80 -i -t ubuntu /bin/bash
<span class="nv">$ </span>docker run -p 8080:80 -i -t ubuntu /bin/bash
<span class="nv">$ </span>docker run -p 0.0.0.0::80 -i -t ubuntu /bin/bash
<span class="nv">$ </span>docker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bash
</pre></div>


<p>另外在容器上也是可以看到对应的端口是否被docker容器监听</p>
<div class="hlcode"><pre><span class="nv">$ </span>netstat -tunlp

Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      778/sshd
tcp6       0      0 :::22                   :::*                    LISTEN      778/sshd
</pre></div>


<h3 id="_6">宿主机添加端口放行</h3>
<p>如果宿主机没有开启 ip 转发功能，会导致外部网络访问宿主机对应端口时没能转发到 Docker Container 所对应的端口上.</p>
<p>如果存在这种情况,则说明宿主机的这些端口对外是关闭的,则需要我们手动去打开.</p>
<div class="hlcode"><pre><span class="nv">$ </span>iptables -A INPUT -p tcp --dport <span class="o">[</span>8080<span class="o">]</span> -j ACCEPT
<span class="nv">$ </span>service iptables save
</pre></div>


<h3 id="docker_4">docker 多端口映射多卷映射</h3>
<p>如果一个参数的选项格式是[],比如<br />
-H=[]host<br />
-p=[]portdirection<br />
这都意味着这个flag可以多次出现，所以此处可以多次指定端口映射规则。</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker run -d -p 80:80 -p 22:22 -it <span class="o">[</span>CONTAINERID<span class="o">]</span>
</pre></div>


<h1 id="docker_5">Docker 文件传输系统</h1>
<h2 id="docker_6">Docker 挂载本地目录</h2>
<p>docker 挂载目录跟端口映射方法类似, 都是需要在docker启动的过程中配置相应的参数.</p>
<p>挂载目录后镜像内就可以共享宿主机里面的文件<br />
通过<code>run -v</code>参数指定挂载目录(格式: 宿主机目录:镜像内挂在目录), 如果宿主机目录不存在则自动创建</p>
<div class="hlcode"><pre><span class="o">-</span><span class="n">v</span> <span class="p">{</span><span class="err">宿主机路径</span><span class="p">}</span><span class="o">:</span><span class="p">{</span><span class="n">docker</span> <span class="n">container</span><span class="err">路径</span><span class="p">}</span>
</pre></div>


<p>实例:</p>
<div class="hlcode"><pre><span class="cp"># 启动一个镜像,运行一个容器, 并设置挂在目录</span>
<span class="n">sudo</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">it</span> <span class="o">-</span><span class="n">v</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span><span class="n">downloads</span><span class="o">/</span><span class="n">data</span><span class="o">:/</span><span class="n">data</span> <span class="p">[</span><span class="n">IMAGE</span> <span class="n">ID</span><span class="o">/</span> <span class="n">REPOSITORY</span><span class="p">]</span>
</pre></div>


<p>此时从宿主机上/home/ubuntu/downloads/文件夹下多出来/data目录</p>
<p>并且,在container中操作/data下面的内容时,宿主机上对应目录下也会有相应的操作.</p>
<p><strong><em>注意</em></strong><br />
1、宿主机目录使用的是绝对路径, 不能使用相对路径</p>
<p>2、如果挂载的是windows下面的文件目录, 则需要设置Docker for windows Shared Drivers, 具体设置过程可以参考<a href="https://blogs.msdn.microsoft.com/stevelasker/2016/06/14/configuring-docker-for-windows-volumes/">docker 官网</a>, 设置完成之后挂在方式不变.</p>
<p>错误提示如下:</p>
<div class="hlcode"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">p</span> <span class="mi">10080</span><span class="o">:</span><span class="mi">80</span> <span class="o">-</span><span class="n">p</span> <span class="mi">10022</span><span class="o">:</span><span class="mi">22</span> <span class="o">-</span><span class="n">p</span> <span class="mi">18080</span><span class="o">:</span><span class="mi">8080</span> <span class="o">-</span><span class="n">p</span> <span class="mi">18000</span><span class="o">:</span><span class="mi">8000</span> <span class="o">-</span><span class="n">it</span> <span class="o">-</span><span class="n">v</span> <span class="n">C</span><span class="o">:</span><span class="err">\</span><span class="n">workshop</span><span class="o">:/</span><span class="n">home</span><span class="o">/</span><span class="n">jerry</span><span class="o">/</span><span class="n">workshop</span><span class="o">/</span><span class="n">venv</span> <span class="mi">3</span><span class="n">cd92bc30026</span>

<span class="o">&gt;&gt;&gt;</span>
<span class="nl">docker:</span> <span class="n">Error</span> <span class="n">response</span> <span class="n">from</span> <span class="n">daemon</span><span class="o">:</span> <span class="n">Drive</span> <span class="n">has</span> <span class="n">not</span> <span class="n">been</span> <span class="n">shared</span><span class="p">.</span>
<span class="n">See</span> <span class="err">&#39;</span><span class="n">docker</span> <span class="n">run</span> <span class="o">--</span><span class="n">help</span><span class="err">&#39;</span><span class="p">.</span>
</pre></div>


<h2 id="docker_7">Docker 和宿主机中相互传递文件</h2>
<h3 id="dockercontainer">根据docker中的container的名字传送</h3>
<div class="hlcode"><pre><span class="c"># Container -&gt; 宿主机</span>
<span class="nv">$ </span>docker cp <span class="o">[</span>OPTIONS<span class="o">]</span> &lt;CONTAINER:SRC_PATH&gt; &lt;DEST_PATH&gt;

<span class="c"># 宿主机 -&gt; Container</span>
<span class="nv">$ </span>docker cp <span class="o">[</span>OPTIONS<span class="o">]</span> &lt;SRC_PATH&gt; &lt;CONTAINER:DEST_PATH&gt;
</pre></div>


<p>示例<br />
将宿主机中 /File_kk目录 拷贝到Container 3000202323dcf 的/home/work目录下.</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker cp File_kk 3000202323dcf:/home/cloude
</pre></div>


<p>将Container 3000202323dcf 的/home/work/File_kk目录 拷贝到宿主机中 /work目录下</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker cp 3000202323dcf:/home/cloude/File_kk /work
</pre></div>


<h3 id="scp">通过scp传送</h3>
<p>如果Container开启ssh服务,则可以通过指定的ssh端口向Container中传送文件,开启ssh服务就可以类似服务器之间传送文件一样.</p>
<div class="hlcode"><pre><span class="nv">$ </span>scp -P &lt;port&gt; &lt;SRC_PATH&gt; &lt;USER_NAME&gt;@&lt;IP&gt;:&lt;DEST_PATH&gt;

<span class="c"># 注,传输文件和文件目录参照scp规则</span>
</pre></div>


<p>示例<br />
假设Container开启了ssh服务,并且与宿主机的端口映射为10022, 现在将jerry.zip复制到Container的/home/jerry/workshop/work</p>
<div class="hlcode"><pre><span class="nv">$ </span>scp -P 10022 jerry.zip jerry@192.168.79.1:/home/jerry/workshop/work
</pre></div>


<h2 id="dockerssh">Docker开启ssh服务</h2>
<h3 id="rootopenssh">修改root密码,安装openssh服务</h3>
<div class="hlcode"><pre><span class="nv">$ </span>apt-get update
<span class="nv">$ </span>apt-get install vim
<span class="nv">$ </span>apt-get install openssh-server
<span class="nv">$ </span>apt-get net-tools
</pre></div>


<h3 id="_7">修改配置文件</h3>
<p>安装成功之后,修改容器的配置文件,使得可以直接使用root登陆</p>
<div class="hlcode"><pre><span class="nv">$ </span>vim  /etc/ssh/sshd_config
</pre></div>


<ul>
<li>在配置文件中找到<code>#PermitRootLogin prohibit-password</code>,修改成<code>PermitRootLogin yes</code></li>
<li>将<code>UsePAM yes</code>, 修改成<code>UsePAM no</code></li>
</ul>
<div class="hlcode"><pre><span class="nv">$ </span>vi /etc/ssh/sshd_config 
<span class="nv">$ </span>PermitRootLogin yes  <span class="c">#允许root用户ssh登录</span>
<span class="nv">$ </span>UsePAM no            <span class="c">##禁用PAM</span>
</pre></div>


<p><strong>注, 如果容器内配置文件不修改,容器可能会拒绝访问,卡在lastlogin提示, 同时还要保证宿主机开启了需要监听的端口</strong></p>
<h3 id="ssh">启动ssh服务</h3>
<div class="hlcode"><pre><span class="nv">$ </span>service ssh start
</pre></div>


<p>我们也可以在启动docker的时候同时启动ssh</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker run -d -it -p 10022:22 &lt;IMAGE_NAME&gt; /usr/sbin/sshd -D
</pre></div>


<h3 id="_8">登录测试</h3>
<p>在宿主机或者其他机器上输入对应的username和ip地址,测试是否可以连接</p>
<div class="hlcode"><pre><span class="nv">$ </span>ssh -p 10022 &lt;username&gt;@&lt;ip&gt;
</pre></div>


<h2 id="docker_8">Docker镜像跨服务器迁移</h2>
<p>Docker的备份方式有export和save两种。</p>
<h3 id="1save">1、save</h3>
<p>1)、镜像保存</p>
<p>登陆到已经部署好镜像的服务器上面，执行以下命令进行导出</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker save &lt;IMAGE_ID前三位&gt; &gt; &lt;IMAGE_NAME&gt;.tar
</pre></div>


<p>or</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker save -o ./&lt;FILE NAME&gt;.tar &lt;EPOSITORY:TAG&gt;
</pre></div>


<p>2)、镜像导入</p>
<p>将刚才导出的镜像上传到你要导入的那台服务器上(使用scp), 执行以下命令镜像导入</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker load &lt; &lt;IMAGE_NAME&gt;.tar
</pre></div>


<p>使用<code>docker images</code>查看你会发现load的镜像的TREPOSITORY和TAG为空, 可以使用下面的命令</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker tag &lt;IMAGE_ID前三位&gt; &lt;REPOSITORY&gt;:&lt;TAG&gt;
</pre></div>


<p>对新load的image重新命名</p>
<h3 id="2export">2、export</h3>
<p>1) 导出容器</p>
<div class="hlcode"><pre><span class="nv">$ </span>docker ps -a
<span class="nv">$ </span>docker <span class="nb">export</span> &lt;CONTAINER ID&gt; &gt; &lt;FILE NMAE&gt;.tar
</pre></div>


<p>2) 导入到指定的服务器</p>
<p>同样需要将刚才的导出的容器备份上传到目标服务器上，执行下面的命令</p>
<div class="hlcode"><pre><span class="nv">$ </span>cat &lt;FILE NMAE&gt;.tar |docker import - &lt;REPOSITORY&gt;:&lt;TAG&gt;
</pre></div>


<p><strong><em>注意：运行导入的镜像的时候必须带command(/bin/bash)，否则启动报如下错误</em></strong></p>
<h3 id="dockerhub">Dockerhub使用</h3>
<h1 id="docker_9">docker 添加用户</h1>
<h1 id="docker_10">docker 三剑客</h1>
<h2 id="docker-machine">docker machine</h2>
<h2 id="docker-swarm">docker swarm</h2>
<p><a href="http://dockone.io/article/2556">Docker 管理工具的选择：Kubernetes 还是 Swarm？</a></p>
<h2 id="docker-compose">docker compose</h2>
<p><a href="https://docs.docker.com/compose/gettingstarted/">Get started with Docker Compose</a></p>
<p><a href="https://www.jianshu.com/p/bf802ea2d7cf">docker-compose运行mysql、redis</a></p>
<p><a href="https://yeasy.gitbooks.io/docker_practice/content/">Docker —— 从入门到实践</a></p>
<h1 id="centosdocker">centos下安装docker</h1>
<p>在使用<code>yum -y install docker</code>和```yum -y install docker-io````失败之后使用</p>
<div class="hlcode"><pre>yum install https://get.docker.com/rpm/1.7.1/centos-6/RPMS/x86_64/docker-engine-1.7.1-1.el6.x86_64.rpm
</pre></div>


<p>安装成功, <code>service docker start</code>启动dokcer即可.</p>
<h3 id="docker-ce">安装docker-ce</h3>
<h4 id="1">方法 1</h4>
<p>安装最新版<br />
1) 安装必要的一些系统工具</p>
<div class="hlcode"><pre><span class="nv">$ </span>sudo yum install -y yum-utils device-mapper-persistent-data lvm2
</pre></div>


<p>2) 添加软件源信息</p>
<div class="hlcode"><pre><span class="nv">$ </span>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</pre></div>


<p>3) 更新并安装 Docker-CE</p>
<div class="hlcode"><pre>sudo yum makecache fast
sudo yum -y install docker-ce
</pre></div>


<p>出现的问题,截图如下</p>
<div class="hlcode"><pre>Public key <span class="k">for </span>docker-ce-cli-18.09.7-3.el7.x86_64.rpm is not installed
<span class="o">(</span>1/3<span class="o">)</span>: docker-ce-cli-18.09.7-3.el7.x86_64.rpm                                                       |  14 MB  00:00:09
<span class="o">(</span>2/3<span class="o">)</span>: docker-ce-18.09.7-3.el7.x86_64.rpm                                                           |  19 MB  00:00:02
containerd.io-1.2.6-3.3.el7.x8 <span class="nv">FAILED</span>                                          <span class="o">=========</span> <span class="o">]</span> 1.9 kB/s |  57 MB  00:10:17 ETA
https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm: <span class="o">[</span>Errno 12<span class="o">]</span> Timeout on https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm: <span class="o">(</span>28, <span class="s1">&#39;Operation too slow. Less than 1000 bytes/sec transferred the last 30 seconds&#39;</span><span class="o">)</span>
Trying other mirror.
containerd.io-1.2.6-3.3.el7.x8 FAILED
https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm: <span class="o">[</span>Errno 14<span class="o">]</span> curl#6 - <span class="s2">&quot;Could not resolve host: mirrors.aliyun.com; Unknown error&quot;</span>
Trying other mirror.


Error downloading packages:
  containerd.io-1.2.6-3.3.el7.x86_64: <span class="o">[</span>Errno 256<span class="o">]</span> No more mirrors to try.
</pre></div>


<p>网上的解决方法:<code>yum clean all</code>后使用<code>yun install docker-ce</code>, 未成功, 错误截图</p>
<div class="hlcode"><pre>Error downloading packages:
  2:container-selinux-2.99-1.el7_6.noarch: <span class="o">[</span>Errno 256<span class="o">]</span> No more mirrors to try.
  3:docker-ce-18.09.7-3.el7.x86_64: <span class="o">[</span>Errno 256<span class="o">]</span> No more mirrors to try.
  containerd.io-1.2.6-3.3.el7.x86_64: <span class="o">[</span>Errno 256<span class="o">]</span> No more mirrors to try.
  1:docker-ce-cli-18.09.7-3.el7.x86_64: <span class="o">[</span>Errno 256<span class="o">]</span> No more mirrors to try.
</pre></div>


<p>// 4. 开启Docker服务(未到这一步)<br />
sudo service docker start</p>
<h4 id="2">方法2</h4>
<ul>
<li>SET UP THE REPOSITORY</li>
</ul>
<p>Install required packages. yum-utils provides the yum-config-manager utility, and device-mapper-persistent-data and lvm2 are required by the devicemapper storage driver.</p>
<div class="hlcode"><pre><span class="nv">$ </span>sudo yum install -y yum-utils <span class="se">\</span>
  device-mapper-persistent-data <span class="se">\</span>
  lvm2
</pre></div>


<p>Use the following command to set up the stable repository.</p>
<div class="hlcode"><pre><span class="nv">$ </span>sudo yum-config-manager <span class="se">\</span>
    --add-repo <span class="se">\</span>
    https://download.docker.com/linux/centos/docker-ce.repo
</pre></div>


<p>Optional: Enable the nightly or test repositories.</p>
<p>These repositories are included in the docker.repo file above but are disabled by default. You can enable them alongside the stable repository. The following command enables the nightly repository.</p>
<div class="hlcode"><pre><span class="nv">$ </span>sudo yum-config-manager --enable docker-ce-nightly
</pre></div>


<p>To enable the test channel, run the following command:</p>
<div class="hlcode"><pre><span class="nv">$ </span>sudo yum-config-manager --enable docker-ce-test
</pre></div>


<p>You can disable the nightly or test repository by running the yum-config-manager command with the --disable flag. To re-enable it, use the --enable flag. The following command disables the nightly repository.</p>
<div class="hlcode"><pre><span class="nv">$ </span>sudo yum-config-manager --disable docker-ce-nightly
</pre></div>


<p>Learn about nightly and test channels.</p>
<p>后面运行的过程中,系统提示会出现下面的提示</p>
<div class="hlcode"><pre><span class="nv">$ </span>sudo yum-config-manager --save --setopt<span class="o">=</span>docker-ce-nightly.skip_if_unavailable<span class="o">=</span><span class="nb">true</span>
</pre></div>


<ul>
<li>INSTALL DOCKER CE</li>
</ul>
<p>Install the latest version of Docker CE and containerd, or go to the next step to install a specific version:</p>
<div class="hlcode"><pre><span class="nv">$ </span>sudo yum install docker-ce docker-ce-cli containerd.io
</pre></div>


<p><strong><em>目前还是没有安装成功</em></strong><br />
失败截图:</p>
<div class="hlcode"><pre>Error downloading packages:
  1:docker-ce-cli-19.03.0-2.3.rc3.el7.x86_64: <span class="o">[</span>Errno 256<span class="o">]</span> No more mirrors to try.
  containerd.io-1.2.6-3.3.el7.x86_64: <span class="o">[</span>Errno 256<span class="o">]</span> No more mirrors to try.
</pre></div>


<p>目前能找到的原因应该是网络的原因, yum安装失败的大部分原因都是网络问题.</p>
<p>第二天早上来运行安装命令, 尝试了两遍之后, 运行成功</p>
<p>第一遍:</p>
<div class="hlcode"><pre><span class="o">[</span>root@localhost psdz<span class="o">]</span><span class="nv">$ </span>sudo yum install docker-ce docker-ce-cli containerd.io
Loaded plugins: fastestmirror, langpacks
Repository base is listed more than once in the configuration
Repository updates is listed more than once in the configuration
Repository extras is listed more than once in the configuration
Repository centosplus is listed more than once in the configuration
Existing lock /var/run/yum.pid: another copy is running as pid 40267.
Another app is currently holding the yum lock; waiting <span class="k">for </span>it to exit...
  The other application is: PackageKit
    Memory :  44 M RSS <span class="o">(</span>386 MB VSZ<span class="o">)</span>
    Started: Thu Jul 18 17:44:11 2019 - 00:01 ago
    State  : Sleeping, pid: 40267
Another app is currently holding the yum lock; waiting <span class="k">for </span>it to exit...
  The other application is: PackageKit
    Memory :  44 M RSS <span class="o">(</span>386 MB VSZ<span class="o">)</span>
    Started: Thu Jul 18 17:44:11 2019 - 00:03 ago
    State  : Sleeping, pid: 40267
Another app is currently holding the yum lock; waiting <span class="k">for </span>it to exit...
  The other application is: PackageKit
    Memory :  44 M RSS <span class="o">(</span>386 MB VSZ<span class="o">)</span>
    Started: Thu Jul 18 17:44:11 2019 - 00:05 ago
    State  : Sleeping, pid: 40267
Loading mirror speeds from cached hostfile
http://mirrors.163.com/centos/7/os/x86_64/repodata/repomd.xml: <span class="o">[</span>Errno 14<span class="o">]</span> curl#6 - <span class="s2">&quot;Could not resolve host: mirrors.163.com; Unknown error&quot;</span>
Trying other mirror.
https://download.docker.com/linux/centos/7/x86_64/stable/repodata/repomd.xml: <span class="o">[</span>Errno 14<span class="o">]</span> curl#6 - <span class="s2">&quot;Could not resolve host:download.docker.com; Unknown error&quot;</span>
Trying other mirror.
docker-ce-test                                                                                      | 3.5 kB  00:00:00
extras                                                                                              | 3.4 kB  00:00:00
libnvidia-container/x86_64/signature                                                                |  488 B  00:00:00
libnvidia-container/x86_64/signature                                                                | 2.0 kB  00:00:00 !!!
nvidia-container-runtime/x86_64/signature                                                           |  488 B  00:00:00
nvidia-container-runtime/x86_64/signature                                                           | 2.0 kB  00:00:00 !!!
nvidia-docker/x86_64/signature                                                                      |  488 B  00:00:00
nvidia-docker/x86_64/signature                                                                      | 2.0 kB  00:00:00 !!!
updates                                                                                             | 3.4 kB  00:00:00
Resolving Dependencies
--&gt; Running transaction check
---&gt; Package containerd.io.x86_64 0:1.2.6-3.3.el7 will be installed
--&gt; Processing Dependency: container-selinux &gt;<span class="o">=</span> 2:2.74 <span class="k">for </span>package: containerd.io-1.2.6-3.3.el7.x86_64
---&gt; Package docker-ce.x86_64 3:19.03.0-2.3.rc3.el7 will be installed
---&gt; Package docker-ce-cli.x86_64 1:19.03.0-2.3.rc3.el7 will be installed
--&gt; Running transaction check
---&gt; Package container-selinux.noarch 2:2.99-1.el7_6 will be installed
--&gt; Finished Dependency Resolution

Dependencies <span class="nv">Resolved</span>

<span class="o">===========================================================================================================================</span>
 Package                        Arch                Version                            Repository                     <span class="nv">Size</span>
<span class="o">===========================================================================================================================</span>
Installing:
 containerd.io                  x86_64              1.2.6-3.3.el7                      docker-ce-stable               26 M
 docker-ce                      x86_64              3:19.03.0-2.3.rc3.el7              docker-ce-test                 24 M
 docker-ce-cli                  x86_64              1:19.03.0-2.3.rc3.el7              docker-ce-test                 39 M
Installing <span class="k">for </span>dependencies:
 container-selinux              noarch              2:2.99-1.el7_6                     extras                         39 k

Transaction <span class="nv">Summary</span>
<span class="o">===========================================================================================================================</span>
Install  3 Packages <span class="o">(</span>+1 Dependent package<span class="o">)</span>

Total size: 90 M
Total download size: 39 M
Installed size: 368 M
Is this ok <span class="o">[</span>y/d/N<span class="o">]</span>: y
Downloading packages:
No Presto metadata available <span class="k">for </span>docker-ce-test
docker-ce-cli-19.03.0-2.3.rc3. FAILED                                                    <span class="o">]</span>  478 B/s |  28 MB  06:47:55 ETA
https://download.docker.com/linux/centos/7/x86_64/test/Packages/docker-ce-cli-19.03.0-2.3.rc3.el7.x86_64.rpm: <span class="o">[</span>Errno 12<span class="o">]</span> Timeout on https://download.docker.com/linux/centos/7/x86_64/test/Packages/docker-ce-cli-19.03.0-2.3.rc3.el7.x86_64.rpm: <span class="o">(</span>28, <span class="s1">&#39;Operation too slow. Less than 1000 bytes/sec transferred the last 30 seconds&#39;</span><span class="o">)</span>
Trying other mirror.
warning: /var/cache/yum/x86_64/7/docker-ce-test/packages/docker-ce-cli-19.03.0-2.3.rc3.el7.x86_64.rpm: Header V4 RSA/SHA512 Signature, key ID 621e9f35: NOKEY
Public key <span class="k">for </span>docker-ce-cli-19.03.0-2.3.rc3.el7.x86_64.rpm is not installed
docker-ce-cli-19.03.0-2.3.rc3.el7.x86_64.rpm                                                        |  39 MB  00:00:12
Retrieving key from https://download.docker.com/linux/centos/gpg


GPG key retrieval failed: <span class="o">[</span>Errno 14<span class="o">]</span> curl#7 - <span class="s2">&quot;Failed to connect to 2600:9000:2016:a800:3:db06:4200:93a1: Network is unreachable&quot;</span>
</pre></div>


<p>第二遍:</p>
<div class="hlcode"><pre><span class="o">[</span>root@localhost psdz<span class="o">]</span><span class="nv">$ </span>sudo yum install docker-ce docker-ce-cli containerd.io
Loaded plugins: fastestmirror, langpacks
Repository base is listed more than once in the configuration
Repository updates is listed more than once in the configuration
Repository extras is listed more than once in the configuration
Repository centosplus is listed more than once in the configuration
Loading mirror speeds from cached hostfile
base                                                                                                | 3.6 kB  00:00:00
docker-ce-stable                                                                                    | 3.5 kB  00:00:00
Resolving Dependencies
--&gt; Running transaction check
---&gt; Package containerd.io.x86_64 0:1.2.6-3.3.el7 will be installed
--&gt; Processing Dependency: container-selinux &gt;<span class="o">=</span> 2:2.74 <span class="k">for </span>package: containerd.io-1.2.6-3.3.el7.x86_64
---&gt; Package docker-ce.x86_64 3:19.03.0-2.3.rc3.el7 will be installed
---&gt; Package docker-ce-cli.x86_64 1:19.03.0-2.3.rc3.el7 will be installed
--&gt; Running transaction check
---&gt; Package container-selinux.noarch 2:2.99-1.el7_6 will be installed
--&gt; Finished Dependency Resolution

Dependencies <span class="nv">Resolved</span>

<span class="o">===========================================================================================================================</span>
 Package                        Arch                Version                            Repository                     <span class="nv">Size</span>
<span class="o">===========================================================================================================================</span>
Installing:
 containerd.io                  x86_64              1.2.6-3.3.el7                      docker-ce-stable               26 M
 docker-ce                      x86_64              3:19.03.0-2.3.rc3.el7              docker-ce-test                 24 M
 docker-ce-cli                  x86_64              1:19.03.0-2.3.rc3.el7              docker-ce-test                 39 M
Installing <span class="k">for </span>dependencies:
 container-selinux              noarch              2:2.99-1.el7_6                     extras                         39 k

Transaction <span class="nv">Summary</span>
<span class="o">===========================================================================================================================</span>
Install  3 Packages <span class="o">(</span>+1 Dependent package<span class="o">)</span>

Total size: 90 M
Installed size: 368 M
Is this ok <span class="o">[</span>y/d/N<span class="o">]</span>: y
Is this ok <span class="o">[</span>y/d/N<span class="o">]</span>: y
Downloading packages:
warning: /var/cache/yum/x86_64/7/docker-ce-test/packages/docker-ce-cli-19.03.0-2.3.rc3.el7.x86_64.rpm: Header V4 RSA/SHA512 Signature, key ID 621e9f35: NOKEY
Retrieving key from https://download.docker.com/linux/centos/gpg
Importing GPG key 0x621E9F35:
 Userid     : <span class="s2">&quot;Docker Release (CE rpm) &lt;docker@docker.com&gt;&quot;</span>
 Fingerprint: 060a 61c5 1b55 8a7f 742b 77aa c52f eb6b 621e 9f35
 From       : https://download.docker.com/linux/centos/gpg
Is this ok <span class="o">[</span>y/N<span class="o">]</span>: y
Running transaction check
Running transaction <span class="nb">test</span>
Transaction <span class="nb">test </span>succeeded
Running transaction
  Installing : 2:container-selinux-2.99-1.el7_6.noarch       1/4
  Installing : containerd.io-1.2.6-3.3.el7.x86_64            2/4
  Installing : 1:docker-ce-cli-19.03.0-2.3.rc3.el7.x86_64    3/4
  Installing : 3:docker-ce-19.03.0-2.3.rc3.el7.x86_64        4/4
  Verifying  : 1:docker-ce-cli-19.03.0-2.3.rc3.el7.x86_64    1/4
  Verifying  : 3:docker-ce-19.03.0-2.3.rc3.el7.x86_64        2/4
  Verifying  : containerd.io-1.2.6-3.3.el7.x86_64            3/4
  Verifying  : 2:container-selinux-2.99-1.el7_6.noarch       4/4

Installed:
  containerd.io.x86_64 0:1.2.6-3.3.el7  docker-ce.x86_64 3:19.03.0-2.3.rc3.el7  docker-ce-cli.x86_64 1:19.03.0-2.3.rc3.el7

Dependency Installed:
  container-selinux.noarch 2:2.99-1.el7_6

Complete!
</pre></div>


<h1 id="centosnvidia-docker2">centos下安装nvidia-docker2</h1>
<div class="hlcode"><pre><span class="c"># If you have nvidia-docker 1.0 installed: we need to remove it and all existing GPU containers</span>
<span class="nv">$ </span>docker volume ls -q -f <span class="nv">driver</span><span class="o">=</span>nvidia-docker | xargs -r -I<span class="o">{}</span> -n1 docker ps -q -a -f <span class="nv">volume</span><span class="o">={}</span> | xargs -r docker rm -f
sudo yum remove nvidia-docker

<span class="c"># Add the package repositories</span>
<span class="nv">$ distribution</span><span class="o">=</span><span class="k">$(</span>. /etc/os-release;echo <span class="nv">$ID$VERSION_ID</span><span class="k">)</span>
<span class="nv">$ </span>curl -s -L https://nvidia.github.io/nvidia-docker/<span class="nv">$distribution</span>/nvidia-docker.repo | <span class="se">\</span>
  sudo tee /etc/yum.repos.d/nvidia-docker.repo

<span class="c"># Install nvidia-docker2 and reload the Docker daemon configuration</span>
<span class="nv">$ </span>sudo yum install -y nvidia-docker2
<span class="nv">$ </span>sudo pkill -SIGHUP dockerd
</pre></div>


<p>安装过程中, 系统会出现以下提示</p>
<div class="hlcode"><pre> One of the configured repositories failed <span class="o">(</span>nvidia-container-runtime<span class="o">)</span>,
 and yum doesn<span class="s1">&#39;t have enough cached data to continue. At this point the only</span>
<span class="s1"> safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:</span>

<span class="s1">     1. Contact the upstream for the repository and get them to fix the problem.</span>

<span class="s1">     2. Reconfigure the baseurl/etc. for the repository, to point to a working</span>
<span class="s1">        upstream. This is most often useful if you are using a newer</span>
<span class="s1">        distribution release than is supported by the repository (and the</span>
<span class="s1">        packages for the previous distribution release still work).</span>

<span class="s1">     3. Run the command with the repository temporarily disabled</span>
<span class="s1">            yum --disablerepo=nvidia-container-runtime ...</span>

<span class="s1">     4. Disable the repository permanently, so yum won&#39;</span>t use it by default. Yum
        will <span class="k">then </span>just ignore the repository <span class="k">until </span>you permanently <span class="nb">enable </span>it
        again or use --enablerepo <span class="k">for </span>temporary usage:

            yum-config-manager --disable nvidia-container-runtime
        or
            subscription-manager repos --disable<span class="o">=</span>nvidia-container-runtime

     5. Configure the failing repository to be skipped, <span class="k">if </span>it is unavailable.
        Note that yum will try to contact the repo. when it runs most commands,
        so will have to try and fail each <span class="nb">time</span> <span class="o">(</span>and thus. yum will be be much
        slower<span class="o">)</span>. If it is a very temporary problem though, this is often a nice
        compromise:

            yum-config-manager --save --setopt<span class="o">=</span>nvidia-container-runtime.skip_if_unavailable<span class="o">=</span><span class="nb">true</span>
</pre></div>


<div class="hlcode"><pre><span class="c"># Test nvidia-smi with the latest official CUDA image</span>
<span class="nv">$ </span>docker run --runtime<span class="o">=</span>nvidia --rm nvidia/cuda:9.0-base nvidia-smi
</pre></div>


<h1 id="_9">参考文献</h1>
<p><a href="https://www.sohu.com/a/156424469_151779">Docker应用配置文件管理的正确姿势</a></p>
<p><a href="https://blog.csdn.net/dongdong9223/article/details/52998375">如何进入、退出docker的container</a></p>
<p><a href="https://github.com/tensorflow/serving/blob/master/tensorflow_serving/g3doc/docker.md">Using TensorFlow Serving via Docker</a></p>
<p><a href="https://segmentfault.com/a/1190000002567459">Docker学习之路（六）用commit命令创建镜像</a></p>
<p><a href="https://www.cnblogs.com/xhyan/p/6593075.html">Docker容器进入的4种方式</a></p>
<p><a href="https://www.cnblogs.com/YasinXiao/p/7736075.html">docker 启动，端口映射，挂载本地目录</a></p>
<p><a href="https://www.jb51.net/article/142459.htm">详解Docker 端口映射与容器互联</a></p>
<p><a href="https://www.jb51.net/article/127630.htm">Docker 给运行中的容器设置端口映射的方法</a></p>
<p><a href="https://www.cnblogs.com/kevingrace/p/9453987.html">Docker容器内部端口映射到外部宿主机端口的方法小结</a></p>
<p><a href="https://www.jb51.net/article/96617.htm">docker容器如何优雅的终止详解</a></p>
<p><a href="https://www.cnblogs.com/xiadongqing/p/6144053.html">docker-image container 基本操作 -常用命令</a></p>
<p><a href="https://www.cnblogs.com/jie-fang/p/7928406.html">Docker实战-为镜像添加SSH服务</a></p>
<p><a href="https://blog.csdn.net/hpf247/article/details/80078240">Linux系统安装docker并用ssh登录docker容器</a></p>
<p><a href="https://blog.csdn.net/qq_39626154/article/details/82856865">Docker 容器开启ssh登录</a></p>
<p><a href="https://github.com/NVIDIA/nvidia-docker">NVIDIA Container Runtime for Docker</a></p>
</div>
<div id="content-footer">created in <span class="create-date date"> 2018-07-25 10:00 </span></div>
<div id="comments"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script type="text/javascript">
const gitment = new Gitment({
  title: 'docker使用教程',
  owner: 'sthsf',
  repo: 'wiki',
  oauth: {
    client_id: '086c54c5fd95adfdc372',
    client_secret: '2ad9ebe87b952d2c77fccf99c334881b91eaa73d',
  },
  // ...
  // For more available options, check out the documentation below
})
gitment.render('comments')
// or
// gitment.render(document.getElementById('comments'))
// or
// document.body.appendChild(gitment.render())
</script>

</div>
<div id="footer">
            <span>
                Copyright © 2020 LiYu.
                Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
                Fork me in <a href="https://github.com/sthsf/wiki" target="_blank"> github </a>.
            </span>
</div>


<!--百度统计-->
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?90e1dcdd1938573c19f9ff6521188e91";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</body>
</html>